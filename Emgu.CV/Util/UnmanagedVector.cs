//----------------------------------------------------------------------------
//
//  Copyright (C) 2004-2021 by EMGU Corporation. All rights reserved.
//
//  Vector of Byte
//
//  This file is automatically generated, do not modify.
//----------------------------------------------------------------------------



using System;
using System.Drawing;
using System.Diagnostics;
using System.Collections.Generic;
using System.IO;
using System.Runtime.InteropServices;
using System.Runtime.Serialization;
using Emgu.CV.Structure;

namespace Emgu.CV.Util
{
    /// <summary>
    /// Wrapped class of the C++ standard vector of Byte.
    /// </summary>

    public abstract class UnmanagedVector : System.IO.Stream
    {
        private long _position = 0;

        /// <summary>
        /// The pointer to the first element on the vector. In case of an empty vector, IntPtr.Zero will be returned.
        /// </summary>
        public abstract IntPtr StartAddress
        {
            get;
        }

        /// <summary>
        /// The pointer to memory address at the end of the vector. In case of an empty vector, IntPtr.Zero will be returned.
        /// </summary>
        public abstract IntPtr EndAddress
        {
            get;
        }

        /*
        /// <summary>
        /// The size of the item in this Vector, counted as size in bytes.
        /// </summary>
        public abstract int SizeOfItemInBytes
        {
            get;
        }*/

        /// <summary>
        /// Get the size of the vector
        /// </summary>
        public abstract int Size
        {
            get;
        }

        /// <inheritdoc/>
        public override long Position
        {
            get
            {
                return _position;
            }
            set
            {
                if (value > Length)
                {
                    throw new IndexOutOfRangeException(String.Format("Position ({0}) is beyond the stream boundary ({1})", value, Length));
                }

                _position = value;
            }
        }

        /// <inheritdoc/>
        public override int Read(byte[] buffer, int offset, int count)
        {
            Int64 start = this.StartAddress.ToInt64();
            Int64 endMax = start + Length;

            IntPtr begin = new IntPtr(start + _position + offset);
            IntPtr end = new IntPtr(Math.Min(begin.ToInt64() + count, endMax));
            int bytesToRead = (int)Math.Min(buffer.Length, end.ToInt64() - begin.ToInt64());
            Marshal.Copy(begin, buffer, 0, bytesToRead);
            
            _position = begin.ToInt64() + bytesToRead - start;

            return bytesToRead;
        }


        /// <inheritdoc/>
        public override long Length
        {
            get { return EndAddress.ToInt64() - StartAddress.ToInt64(); }
        }

        /// <inheritdoc/>
        public override void SetLength(long value)
        {
            throw new NotSupportedException("Set length is not supported");
        }

        /// <inheritdoc/>
        public override bool CanRead
        {
            get { return true; }
        }

        /// <inheritdoc/>
        public override bool CanWrite
        {
            get { return false; }
        }

        /// <inheritdoc/>
        public override bool CanSeek
        {
            get { return false; }
        }

        /// <inheritdoc/>
        public override long Seek(long offset, SeekOrigin origin)
        {
            throw new NotSupportedException("Seek is not supported");
        }

        /// <inheritdoc/>
        public override void Write(byte[] buffer, int offset, int count)
        {
            throw new NotSupportedException("Write is not supported");
        }

        /// <inheritdoc/>
        public override void Flush()
        {
            throw new NotSupportedException("Flush is not supported");
        }

        #region DisposableObject
        /// <summary> Track whether Dispose has been called. </summary>
        private bool _disposed;

        /// <summary>
        /// The dispose function that implements IDisposable interface
        /// </summary>
        public new void Dispose()
        {
            Dispose(true);
            GC.SuppressFinalize(this);
        }

        /// <summary> 
        /// Dispose(bool disposing) executes in two distinct scenarios.
        /// If disposing equals true, the method has been called directly
        /// or indirectly by a user's code. Managed and unmanaged resources
        /// can be disposed.
        /// If disposing equals false, the method has been called by the
        /// runtime from inside the finalizer and you should not reference
        /// other objects. Only unmanaged resources can be disposed.
        /// </summary>
        /// <param name="disposing"> If disposing equals false, the method has been called by the runtime from inside the finalizer and you should not reference other objects. Only unmanaged resources can be disposed. </param>
        protected override void Dispose(bool disposing)
        {
            // Check to see if Dispose has already been called.
            if (!_disposed)
            {
                _disposed = true;

                // If disposing equals true, release all managed resources as well
                if (disposing)
                {
                    ReleaseManagedResources();
                }

                //release unmanaged resource.
                DisposeObject();
            }
        }

        /// <summary>
        /// Release the managed resources. This function will be called during the disposal of the current object.
        /// override ride this function if you need to call the Dispose() function on any managed IDisposable object created by the current object
        /// </summary>
        protected virtual void ReleaseManagedResources()
        {
        }

        /// <summary>
        /// Release the unmanaged resources
        /// </summary>
        protected abstract void DisposeObject();

        /// <summary>
        /// Destructor
        /// </summary>
        ~UnmanagedVector()
        {
            Dispose(false);
        }
        #endregion

        #region UnmanagedObject
        /// <summary>
        /// A pointer to the unmanaged object
        /// </summary>
        protected IntPtr _ptr;

        /// <summary>
        /// Pointer to the unmanaged object
        /// </summary>
        public IntPtr Ptr
        {
            get
            {
                return _ptr;
            }
        }

        /// <summary>
        /// Implicit operator for IntPtr
        /// </summary>
        /// <param name="obj">The UnmanagedObject</param>
        /// <returns>The unmanaged pointer for this object</returns>
        public static implicit operator IntPtr(UnmanagedVector obj)
        {
            return obj == null ? IntPtr.Zero : obj._ptr;
        }
        #endregion
    }
}


